/*
 * API микросервиса общих справочников
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package ru.softlab.efr.common.client;

import ru.softlab.efr.common.dict.exchange.model.Address;
import ru.softlab.efr.common.dict.exchange.model.House;
import ru.softlab.efr.common.dict.exchange.model.RegionRs;

import ru.softlab.efr.infrastructure.transport.client.*;
import ru.softlab.efr.common.utilities.rest.*;
import ru.softlab.efr.common.utilities.rest.client.*;
import ru.softlab.efr.common.utilities.rest.converters.DateParser;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import ru.softlab.efr.infrastructure.transport.client.impl.JmsUriBuilder;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.util.*;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.stereotype.Component;

import java.util.*;

/**
 * Содержит методы для взаимодействия с приложением common-dict-app
 **/
@Component
public class AddressesClient {
    private static final String REQUIRED_PARAM_ERROR = "Не указан обязательный параметр '%s' при вызове %s";
    private static final String APPLICATION_NAME = "common-dict-app";
    private static final String STATUS_CODE_TEMPLATE = "status code: [%s]";

    private final MicroServiceTemplate microServiceTemplate;

    /**
     * Возвращяет экземпляр класса
     * @param microServiceTemplate - объект, реализующий интерфейс {@link MicroServiceTemplate}
     */
    public AddressesClient(MicroServiceTemplate microServiceTemplate) {
        this.microServiceTemplate = microServiceTemplate;
    }


    /**
     * Возвращает информацию об адресе
     * GET /dictionaries/addresses/{id}
     *
     * @param id Идентификатор адреса (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Информация об адресе
     * @throws RestClientException в случае неудачи
    */
    public Address getAddress(Long id, long timeout) throws RestClientException {
        return getAddress(id).get(timeout);
    }

    /**
     * Возвращает информацию об адресе асинхронно
     * GET /dictionaries/addresses/{id}
     *
     * @param id Идентификатор адреса (required)
     * @return Информация об адресе
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Address> getAddress(Long id) throws RestClientException {
        return new ClientRestResult<>(getAddressInternal(id), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Address>> getAddressInternal(Long id) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "getAddress"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(APPLICATION_NAME)
            .path(cutComments("/dictionaries/addresses/{id}")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Address>(){});
    }

    /**
     * Возвращает список родительских адресов
     * GET /dictionaries/addresses/{id}/parents
     *
     * @param id Идентификатор адреса (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Список адресов
     * @throws RestClientException в случае неудачи
    */
    public List<Address> getParents(Long id, long timeout) throws RestClientException {
        return getParents(id).get(timeout);
    }

    /**
     * Возвращает список родительских адресов асинхронно
     * GET /dictionaries/addresses/{id}/parents
     *
     * @param id Идентификатор адреса (required)
     * @return Список адресов
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<List<Address>> getParents(Long id) throws RestClientException {
        return new ClientRestResult<>(getParentsInternal(id), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<List<Address>>> getParentsInternal(Long id) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "getParents"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(APPLICATION_NAME)
            .path(cutComments("/dictionaries/addresses/{id}/parents")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<List<Address>>(){});
    }

    /**
     * Возвращает список адресных объектов уровня 1
     * GET /dictionaries/addresses/region/list
     *
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Ответ на запрос получения списка регионов
     * @throws RestClientException в случае неудачи
    */
    public RegionRs getRegionList(long timeout) throws RestClientException {
        return getRegionList().get(timeout);
    }

    /**
     * Возвращает список адресных объектов уровня 1 асинхронно
     * GET /dictionaries/addresses/region/list
     *
     * @return Ответ на запрос получения списка регионов
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<RegionRs> getRegionList() throws RestClientException {
        return new ClientRestResult<>(getRegionListInternal(), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<RegionRs>> getRegionListInternal() throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(APPLICATION_NAME)
            .path(cutComments("/dictionaries/addresses/region/list"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<RegionRs>(){});
    }

    /**
     * Список адресов
     * GET /dictionaries/addresses
     *
     * @param words Слова поиска (required)
     * @param parentId Id родительской записи адреса, относительно которой производится поиск (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Список результатов поиска
     * @throws RestClientException в случае неудачи
    */
    public List<Address> listAddresses(String words, Long parentId, long timeout) throws RestClientException {
        return listAddresses(words, parentId).get(timeout);
    }

    /**
     * Список адресов асинхронно
     * GET /dictionaries/addresses
     *
     * @param words Слова поиска (required)
     * @param parentId Id родительской записи адреса, относительно которой производится поиск (optional)
     * @return Список результатов поиска
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<List<Address>> listAddresses(String words, Long parentId) throws RestClientException {
        return new ClientRestResult<>(listAddressesInternal(words, parentId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<List<Address>>> listAddressesInternal(String words, Long parentId) throws RestClientException {
        if (words == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "words", "listAddresses"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(APPLICATION_NAME)
            .path(cutComments("/dictionaries/addresses"));

        if (words != null)
            uriBuilder.param("words", words);
        if (parentId != null)
            uriBuilder.param("parentId", parentId);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<List<Address>>(){});
    }

    /**
     * Список строений
     * GET /dictionaries/addresses/{id}/houses
     *
     * @param id Id родительской записи адреса, относительно которой производится поиск строений (required)
     * @param house Номер дома (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Список результатов поиска
     * @throws RestClientException в случае неудачи
    */
    public List<House> listHouses(Long id, String house, long timeout) throws RestClientException {
        return listHouses(id, house).get(timeout);
    }

    /**
     * Список строений асинхронно
     * GET /dictionaries/addresses/{id}/houses
     *
     * @param id Id родительской записи адреса, относительно которой производится поиск строений (required)
     * @param house Номер дома (optional)
     * @return Список результатов поиска
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<List<House>> listHouses(Long id, String house) throws RestClientException {
        return new ClientRestResult<>(listHousesInternal(id, house), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<List<House>>> listHousesInternal(Long id, String house) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "listHouses"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(APPLICATION_NAME)
            .path(cutComments("/dictionaries/addresses/{id}/houses")).variable("id", id);

        if (house != null)
            uriBuilder.param("house", house);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<List<House>>(){});
    }

    /**
     * Репликация адресов и строений
     * POST /dictionaries/addresses/replication
     *
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void replicationAddresses(long timeout) throws RestClientException {
        return replicationAddresses().get(timeout);
    }

    /**
     * Репликация адресов и строений асинхронно
     * POST /dictionaries/addresses/replication
     *
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> replicationAddresses() throws RestClientException {
        return new ClientRestResult<>(replicationAddressesInternal(), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> replicationAddressesInternal() throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(APPLICATION_NAME)
            .path(cutComments("/dictionaries/addresses/replication"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Обновление адресов и строений
     * POST /dictionaries/addresses/update
     *
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void updateAddresses(long timeout) throws RestClientException {
        return updateAddresses().get(timeout);
    }

    /**
     * Обновление адресов и строений асинхронно
     * POST /dictionaries/addresses/update
     *
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> updateAddresses() throws RestClientException {
        return new ClientRestResult<>(updateAddressesInternal(), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> updateAddressesInternal() throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(APPLICATION_NAME)
            .path(cutComments("/dictionaries/addresses/update"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }
    private String cutComments(String path) {
        return path.split("#", 2)[0];
    }

    private void addPageableParams(MicroServiceURIBuilder builder, Pageable pageable) {
        if (pageable != null) {
            builder.param("page", pageable.getPageNumber());
            builder.param("size", pageable.getPageSize());
            Sort sort = pageable.getSort();
            if (sort != null) {
                List<String> sortParams = new ArrayList<>();
                for (Sort.Order next : sort) {
                    sortParams.add(next.getProperty());
                }
                sortParams.add(sort.getOrderFor(sortParams.get(0)).getDirection().name());
                builder.param("sort", String.join(",", sortParams));
            }
        }
    }

    private void processStatusCodeErrors(Exception e) throws RestClientException {
            HttpStatus statusCode = RestUtils.getStatusCode(e);
            if (statusCode != null) {
                switch (statusCode) {
                    case INTERNAL_SERVER_ERROR:
                        throw new RestClientException(String.format(STATUS_CODE_TEMPLATE, HttpStatus.INTERNAL_SERVER_ERROR.toString()));
                    case CONFLICT:
                        throw new EntityExistsException();
                    case NOT_FOUND:
                        throw new NotFoundException();
                }
            }
            throw new RestClientException(e.toString());
    }
}
